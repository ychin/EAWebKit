/*H*************************************************************************************/
/*!
    \File dirtywebapi2ps5.c

    \Description
        DirtyWebApi2PS5 encapsulates use of the Sce's SessionInvitation API for
        creating, modifying, inviting and joining.

    \Copyright
        Copyright (c) / Electronic Arts 2013.  ALL RIGHTS RESERVED.

    \Version 1.0 05/09/2013 (mcorcoran)  First Version
*/
/*************************************************************************************H*/


/*** Include files *********************************************************************/
#include <sdk_version.h>
#include <string.h>
#include <scetypes.h>
#include <net.h>
#include <np.h>

#include "DirtySDK/dirtysock.h"
#include "DirtySDK/dirtysock/dirtymem.h"
#include "DirtySDK/dirtysock/dirtyerr.h"
#include "DirtySDK/dirtysock/dirtythread.h"
#include "DirtySDK/dirtysock/ps4/dirtycontextmanagerps4.h"
#include "DirtySDK/dirtysock/netconn.h"
#include "DirtySDK/dirtysock/ps5/dirtywebapi2ps5.h"
#include "DirtySDK/util/jsonparse.h"
#include "DirtySDK/proto/protohttputil.h"
/*** Defines ***************************************************************************/
#define DIRTY_WEBAPI2_NET_HEAP_NAME    "DirtyWebApi2"

//! default memory sizes
#define DIRTY_WEBAPI2_NET_HEAP_SIZE       (16 * 1024)
#define DIRTY_WEBAPI2_SSL_HEAP_SIZE       (384 * 1024)
#define DIRTY_WEBAPI2_HEAP_SIZE           (512 * 1024)
#define DIRTY_WEBAPI2_READ_BUFFER_SIZE    (2 * 1024)
#define DIRTY_WEBAPI2_ERROR_BUFFER_SIZE   (1 * 1024)
#define DIRTY_WEBAPI2_CONCURRENT_REQUEST  (3)

//! default number of push events
#define DIRTY_WEBAPI2_MAX_PUSH_EVENTS  (16)

//! maximum number of defered deletes
#define DIRTY_WEBAPI2_MAX_DEFERED_DELETES        (100)
#define DIRTY_WEBAPI2_MAX_DEFERED_DELETE_TIMEOUT (5000)

/*** Macros ****************************************************************************/
/*** Type Definitions ******************************************************************/

typedef enum DirtyWebApi2EventTypeE
{
    DIRTYWEBAPI2_PUSH_EVENT,          //!< push event type
    DIRTYWEBAPI2_PUSH_EVENT_CONTEXT   //!< push event context
} DirtyWebApi2EventTypeE;

typedef enum DirtyWebApi2CallbackEntryTypeE
{
    DIRTYWEBAPI2_EVENT_CALLBACK,    //!< event callback
    DIRTYWEBAPI2_REQUEST_CALLBACK   //!< resquest callback
} DirtyWebApi2CallbackEntryTypeE;

typedef struct DirtyWebApi2EventCallbackT
{
    union
    {
        DirtyWebApiPushEventCallbackT *pPushEventCallback;               // push event callback
        DirtyWebApiPushEventConextCallbackT *pPushEventContextCallback;  // push event context callback
    };

    DirtyWebApi2EventTypeE eEventType;
} DirtyWebApi2EventCallbackT;

typedef struct DirtyWebApi2WebRequestT
{
    struct DirtyWebApi2WebRequestT *pNext;
    struct DirtyWebApi2WebRequestT *pPrev;
    DirtyWebApiCallbackT *pCallback;             //!< the callback that is called when a response is received or an error occurs
    void *pUserData;
    int64_t iWebRequestId;
    int32_t iContentLength;
    int32_t iUserIndex;
    char pContent[1];
} DirtyWebApi2WebRequestT;

typedef struct DirtyWebApi2UserT
{
    SceUserServiceUserId    aSceUserId;         //!< simple id, similar to an int
    int32_t                 iWebapi2UserCtxId;   //!< context for this user to use to execute webapi commands
} DirtyWebApi2UserT;

typedef struct DirtyWebApi2PushEventT
{
    int32_t aCallBackIds[NETCONN_MAXLOCALUSERS];        //!< stores a per user id for each event registered
    void *pUserData;                                    //!< user pointer which they receive back when the callback fires
    const char *pSceEventDataType;                      //!< description of what type of event we're listening for (for generating filter), defined by sony
    int32_t iFilterId;                                  //!< id of generated event filter (produced by sony apis)
    int32_t iRequestId;                                 //!< id generated by dirtysdk at time request is initially made
    const char *pNpServiceName;                         //!< further description on what type of event we're listening for
    SceNpServiceLabel npServiceLabel;                   //!< further description on what type of event we're listening for
    DirtyWebApi2EventCallbackT Callback;                //!< callback
    DirtyWebApiRefT *pRef;                              //!< dirtywebapi module state

    struct DirtyWebApi2PushEventT *pNext;
} DirtyWebApi2PushEventT;

//! a list of event registrations
typedef struct DirtyWebApi2PushEventsT
{
    DirtyWebApi2PushEventT aEvents[DIRTY_WEBAPI2_MAX_PUSH_EVENTS]; //!< list of events we're listening for
    int32_t iEventHandle;                                          //!< event handle
    int32_t iEventCount;                                           //!< current number of events we are listening for
} DirtyWebApi2PushEventsT;

//! request callback entry
typedef struct DirtyWebApi2RequestCallbackEntryT
{
    DirtyWebApiCallbackT *pCallback;    //!< callback
    int32_t iSceError;                  //!< sce error
    int32_t iUserIndex;                 //!< user index
    int32_t iStatusCode;                //!< http status code
    char *pRespBody;                    //!< response body
    int32_t iRespBodyLength;            //!< response body length
    void *pUserData;                    //!< user data
} DirtyWebApi2RequestCallbackEntryT;

//! push event callback entry
typedef struct DirtyWebApi2EventCallbackEntryT
{
    char *pNpServiceName;                                                   //!< NP service name
    char *pData;                                                            //!< data buffer
    size_t sDataLen;                                                        //!< data len
    int32_t iUserCtxId;                                                     //!< user web api context
    int32_t iCallbackId;                                                    //!< callback id generated at registration
    SceNpPeerAddressA To;                                                   //!< contains the account id of target user
    SceNpPeerAddressA From;                                                 //!< contains the account id of source user
    SceNpServiceLabel ServiceLabel;                                         //!< NP Service Label
    SceNpWebApi2PushEventDataType EventDataType;                            //!< event data type
    SceNpWebApi2PushEventPushContextCallbackType PushConextCallbackType;    //!< push context callback type
    SceNpWebApi2PushEventPushContextId PushContextId;                       //!< push context id
    DirtyWebApi2EventCallbackT EventCallback;                               //!< event callback
    void *pUserArg;                                                         //!< user data
} DirtyWebApi2EventCallbackEntryT;

//! a list of dirtywebapi callback to be executed
typedef struct DirtyWebApi2CallbackEntryT
{
    struct DirtyWebApi2CallbackEntryT *pNext;       //!< next callback entry
    DirtyWebApi2CallbackEntryTypeE eCallbackType;   //!< callback type

    union
    {
        DirtyWebApi2RequestCallbackEntryT RequestCallbackEntry;    //!< request callback
        DirtyWebApi2EventCallbackEntryT EventCallbackEntry;         //!< event callback

    };

} DirtyWebApi2CallbackEntryT;

//! internal module state
struct DirtyWebApiRefT
{
    void                *pMemGroupUserData;              //!< user data associated with mem group
    int32_t             iMemGroup;                       //!< module mem group id

    int32_t             iNetPoolCtxId;                    //!< context for sceNetPool*
    int32_t             iSslCtxId;                        //!< context for sceSsl*
    int32_t             iHttp2CtxId;                      //!< context for sceHttp2*
    int32_t             iWebApi2CtxId;                    //!< context for sceNpWebApi*
    int32_t             iPushEventRequestCount;           //!< counter to be used by dirtysdk to give a unique id to push event requests

    struct DirtyWebApi2WebRequestT * pCurrentWebRequest;  //!< web request in action

    volatile int32_t    iThreadLife;       //!< used in condition to let thread self terminate >=0 alive, < 0 terminate
    NetCritT            crit;              //!< sychronize shared data between the threads
    NetCritT            requestCrit;       //!< sychronize shared data between the threads

    char               *aReadBuffer;       //!< buffer for data from WebApi
    uint32_t            uReadBufferSize;   //!< buffer size
    uint8_t             bQueueCallback;    //!< queue request callback
    uint8_t             bAutoUpdate;       //!< do we want to update from the netconn idler?
    uint8_t             _pad[2];

    struct DirtyWebApi2WebRequestT *pRequestListFront; //!< the front of the FIFO web request queue - this request is the one that gets serviced
    struct DirtyWebApi2WebRequestT *pRequestListBack;  //!< the back of the FIFO web request queue - additional requests are added to the back

    struct DirtyWebApi2CallbackEntryT *pCallbackListFront;  //!< the front of the FIFO web request callback queue
    struct DirtyWebApi2CallbackEntryT *pCallbackListBack;   //!< the back of the FIFO web request callback queue

    DirtyWebApi2UserT webApi2Users[NETCONN_MAXLOCALUSERS]; //!< state for each user, they must each manipulate the session api
    DirtyWebApi2PushEventT *pPendingPushEvents;            //!< list of push events that needs to be registered async
    DirtyWebApi2PushEventsT PushEvents;                    //!< array of push events the user has registered for

    DirtyConditionRefT *pDirtyWepApiThreadCond;       //!< condition variable to wakeup webapi thread
    NetCritT DirtyWebApiThreadMutex;                  //!< mutex associated with pDirtyWepApiThreadCond
};

/*** Private Functions *****************************************************************/

static int32_t _DirtyWebApi2SetupWebUserContext(DirtyWebApiRefT *pRef, int32_t iUserIndex);
static int32_t _DirtyWebApi2CleanupRequestQueue(DirtyWebApiRefT *pRef, int32_t iUserIndex, int64_t iWebRequestId);
static void _DirtyWebApi2CleanupWebUserContext(DirtyWebApiRefT *pRef, int32_t iUserIndex);
static void _DirtyWebApi2AddEventCalbackToQueue(DirtyWebApiRefT *pRef, DirtyWebApi2EventTypeE eEventType, int32_t iUserCtxId, int32_t iCallbackId, const SceNpWebApi2PushEventPushContextId *pPushCtxId,
    SceNpWebApi2PushEventPushContextCallbackType cbType, const char *pNpServiceName, SceNpServiceLabel npServiceLabel, const SceNpPeerAddressA *pTo, const SceNpPeerAddressA *pFrom,
    const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen, void *pUserArg);

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApiCallbackNpWebApi2PushEventContext

    \Description
        Intermediate callback, to call the users callback.

    \Input iUserCtxId       - user web api context
    \Input iCallbackId      - callback id generated at registration
    \Input pPushCtxId       - push event push context id
    \Input cbType           - SceNpWebApi2PushEventPushContextCallbackType type
    \Input pNpServiceName   - NP Service Name
    \Input npServiceLabel   - NP Service Label
    \Input pTo              - contains the account id of target user
    \Input pToOnlineId      - Online Id of target user
    \Input pFrom            - contains the account id of source user
    \Input pFromOnlineId    - Online Id of source user
    \Input pDataType        - event type
    \Input pData            - any data coming with the event
    \Input dataLen          - length of data with the event
    \Input pExtdData        - SceNpWebApi2PushEventExtdData extended data
    \Input extdDataNum      - extended data size
    \Input pUserArg         - pointer to the DirtyWebApi2PushEventT that generated this event

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
static void _DirtyWebApiCallbackNpWebApi2PushEventContext(int32_t iUserCtxId, int32_t iCallbackId, const SceNpWebApi2PushEventPushContextId *pPushCtxId, SceNpWebApi2PushEventPushContextCallbackType cbType, const char *pNpServiceName,
    SceNpServiceLabel npServiceLabel, const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId, const SceNpWebApi2PushEventDataType *pDataType, const char *pData,
    size_t dataLen, const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
{
    DirtyWebApi2PushEventT *pEvent = (DirtyWebApi2PushEventT *)pUserArg;
    _DirtyWebApi2AddEventCalbackToQueue(pEvent->pRef, DIRTYWEBAPI2_PUSH_EVENT_CONTEXT, iUserCtxId, iCallbackId, pPushCtxId, cbType, NULL, SCE_NP_DEFAULT_SERVICE_LABEL, pTo, pFrom, pDataType, pData, dataLen, pUserArg);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApiCallbackNpWebApi2ServicePushEventContext

    \Description
        Intermediate callback, to call the users callback.

    \Input iUserCtxId       - user web api context
    \Input iCallbackId      - callback id generated at registration
    \Input pPushCtxId       - push event push context id
    \Input cbType           - SceNpWebApi2PushEventPushContextCallbackType type
    \Input pNpServiceName   - NP Service Name
    \Input npServiceLabel   - NP Service Label
    \Input pTo              - contains the account id of target user
    \Input pToOnlineId      - Online Id of target user
    \Input pFrom            - contains the account id of source user
    \Input pFromOnlineId    - Online Id of source user
    \Input pDataType        - event type
    \Input pData            - any data coming with the event
    \Input dataLen          - length of data with the event
    \Input pExtdData        - SceNpWebApi2PushEventExtdData extended data
    \Input extdDataNum      - extended data size
    \Input pUserArg         - pointer to the DirtyWebApi2PushEventT that generated this event

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
static void _DirtyWebApiCallbackNpWebApi2ServicePushEventContext(int32_t iUserCtxId, int32_t iCallbackId, const SceNpWebApi2PushEventPushContextId *pPushCtxId, SceNpWebApi2PushEventPushContextCallbackType cbType, const char *pNpServiceName,
    SceNpServiceLabel npServiceLabel, const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId, const SceNpWebApi2PushEventDataType *pDataType, const char *pData,
    size_t dataLen, const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
{
    DirtyWebApi2PushEventT *pEvent = (DirtyWebApi2PushEventT *)pUserArg;
    _DirtyWebApi2AddEventCalbackToQueue(pEvent->pRef, DIRTYWEBAPI2_PUSH_EVENT_CONTEXT, iUserCtxId, iCallbackId, pPushCtxId, cbType, pNpServiceName, npServiceLabel, pTo, pFrom, pDataType, pData, dataLen, pUserArg);
}


/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApiCallbackNpWebApi2PushEvent

    \Description
        Intermediate callback, to call the users callback.

    \Input iUserCtxId       - user web api context
    \Input iCallbackId      - callback id generated at registration
    \Input pNpServiceName   - NP Service Name
    \Input npServiceLabel   - NP Service Label
    \Input pTo              - contains the account id of target user
    \Input pToOnlineId      - Online Id of target user
    \Input pFrom            - contains the account id of source user
    \Input pFromOnlineId    - Online Id of source user
    \Input pDataType        - event type
    \Input pData            - any data coming with the event
    \Input dataLen          - length of data with the event
    \Input pExtdData        - SceNpWebApi2PushEventExtdData extended data
    \Input extdDataNum      - extended data size
    \Input pUserArg         - pointer to the DirtyWebApi2PushEventT that generated this event

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
static void _DirtyWebApiCallbackNpWebApi2PushEvent(int32_t iUserCtxId, int32_t iCallbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel, const SceNpPeerAddressA *pTo,
    const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId, const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
    const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
{
    DirtyWebApi2PushEventT *pEvent = (DirtyWebApi2PushEventT*)pUserArg;
    _DirtyWebApi2AddEventCalbackToQueue(pEvent->pRef, DIRTYWEBAPI2_PUSH_EVENT, iUserCtxId, iCallbackId, NULL, 0, NULL, SCE_NP_DEFAULT_SERVICE_LABEL, pTo, pFrom, pDataType, pData, dataLen, pUserArg);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApiCallbackNpWebApi2ServicePushEvent

    \Description
        Intermediate callback, to call the users callback.

    \Input iUserCtxId       - user web api context
    \Input iCallbackId      - callback id generated at registration
    \Input pNpServiceName   - NP web service generating the event
    \Input npServiceLabel   - more detail on the web service
    \Input pTo              - contains the account id of target user
    \Input pToOnlineId      - online id of target user
    \Input pFrom            - contains the account id of source user
    \Input pFromOnlineId    - online id of source user
    \Input pDataType        - event type
    \Input pData            - any data coming with the event
    \Input dataLen          - length of data with the event
    \Input pExtdData        - SceNpWebApi2PushEventExtdData extended data
    \Input extdDataNum      - size of extended data
    \Input pUserArg         - pointer to the DirtyWebApi2PushEventT that generated this event

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
static void _DirtyWebApiCallbackNpWebApi2ServicePushEvent(int32_t iUserCtxId, int32_t iCallbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
    const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
    const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen, const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
{
    DirtyWebApi2PushEventT *pEvent = (DirtyWebApi2PushEventT*)pUserArg;
    _DirtyWebApi2AddEventCalbackToQueue(pEvent->pRef, DIRTYWEBAPI2_PUSH_EVENT_CONTEXT, iUserCtxId, iCallbackId, NULL, 0, pNpServiceName, npServiceLabel, pTo, pFrom, pDataType, pData, dataLen, pUserArg);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2InitPushEvents

    \Description
        Set the default state of the push event structures.

    \Input pRef             - module state

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2InitPushEvents(DirtyWebApiRefT *pRef)
{
    if ((pRef->PushEvents.iEventHandle = sceNpWebApi2PushEventCreateHandle(pRef->iWebApi2CtxId)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2InitPushEventsAndContext, sceNpWebApi2PushEventCreateHandle() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.iEventHandle)));
    }

    for (int32_t iEvent = 0; iEvent < DIRTY_WEBAPI2_MAX_PUSH_EVENTS; iEvent++)
    {
        pRef->PushEvents.aEvents[iEvent].iFilterId = -1;
        pRef->PushEvents.aEvents[iEvent].iRequestId = -1;

        for (int32_t iUser = 0; iUser < NETCONN_MAXLOCALUSERS; iUser++)
        {
            pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUser] = -1;
        }
    }
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2DestroyPushEvents

    \Description
        Unregister any active events and free resources

    \Input pRef             - module state

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2DestroyPushEvents(DirtyWebApiRefT *pRef)
{
    int32_t iRet;

    for (int32_t iEvent = 0; iEvent < pRef->PushEvents.iEventCount; iEvent++)
    {
        for (int32_t iUser = 0; iUser < NETCONN_MAXLOCALUSERS; iUser++)
        {
            if (pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUser] >= 0)
            {
                if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                {
                    if ((iRet = sceNpWebApi2PushEventUnregisterCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUser])) != SCE_OK)
                    {
                        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2DestroyPushEvents, sceNpWebApi2PushEventUnregisterCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
                    }
                }
                else if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                {
                    if ((iRet = sceNpWebApi2PushEventUnregisterPushContextCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUser])) != SCE_OK)
                    {
                        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2DestroyPushEvents, sceNpWebApi2PushEventUnregisterPushContextCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
                    }
                }
            }
            pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUser] = -1;
        }

        if (pRef->PushEvents.aEvents[iEvent].iFilterId > 0)
        {
            if ((iRet = sceNpWebApi2PushEventDeleteFilter(pRef->iWebApi2CtxId, pRef->PushEvents.aEvents[iEvent].iFilterId)) != SCE_OK)
            {
                NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2DestroyPushEvents, sceNpWebApi2PushEventDeleteFilter() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
            }

            pRef->PushEvents.aEvents[iEvent].iFilterId = -1;
        }

        pRef->PushEvents.aEvents[iEvent].iRequestId = -1;
    }

    if (pRef->PushEvents.iEventHandle > 0)
    {
        if ((iRet = sceNpWebApi2PushEventDeleteHandle(pRef->iWebApi2CtxId, pRef->PushEvents.iEventHandle)) != SCE_OK)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2DestroyPushEvents, sceNpWebApi2PushEventDeleteHandle() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }

        pRef->PushEvents.iEventHandle = -1;
    }
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2AddPushEventAsync

    \Description
        Add push event to pending list

    \Input pRef             - module state
    \Input eventType        - event type from sony
    \Input pNpServiceName   - NP web service generating the event
    \Input npServiceLabel   - more detail on the web service
    \Input pCallback        - DirtyWebApi2EventCallbackT callback to call when even triggers
    \Input pUserData        - data passed to the callback when it triggers

    \Version 10/09/2013 (tcho)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2AddPushEventAsync(DirtyWebApiRefT *pRef, const char * eventType, const char * pNpServiceName, SceNpServiceLabel npServiceLabel, DirtyWebApi2EventCallbackT *pCallback, void *pUserData)
{
    DirtyWebApi2PushEventT *pPushEvent = (DirtyWebApi2PushEventT *)DirtyMemAlloc(sizeof(DirtyWebApi2PushEventT), DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
    ds_memclr(pPushEvent, sizeof(DirtyWebApi2PushEventT));

    pPushEvent->pRef = pRef;
    pPushEvent->pNpServiceName = pNpServiceName;
    pPushEvent->npServiceLabel = npServiceLabel;
    pPushEvent->pUserData = pUserData;
    pPushEvent->pSceEventDataType = eventType;
    ds_memcpy(&pPushEvent->Callback, pCallback, sizeof(DirtyWebApi2EventCallbackT));

    //Adding Push Events to the Pending List
    NetCritEnter(&pRef->DirtyWebApiThreadMutex);
    NetCritEnter(&pRef->crit);

    // give it unique request id
    pPushEvent->iRequestId = pRef->iPushEventRequestCount++;

    pPushEvent->pNext = pRef->pPendingPushEvents;
    pRef->pPendingPushEvents = pPushEvent;

    NetCritLeave(&pRef->crit);

    // signal webapi thread to do work
    if (!DirtyConditionSignal(pRef->pDirtyWepApiThreadCond))
    {
        NetPrintf(("dirtywebapi2ps5: [%p] failed to signal webapi thread.\n", pRef));
    }
    NetCritLeave(&pRef->DirtyWebApiThreadMutex);

    return(pPushEvent->iRequestId);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2AddPushEvent

    \Description
        Adds a registeration for Push events

    \Input pRef             - module state
    \Input pPushEvent       - struct containing information about the event

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2AddPushEvent(DirtyWebApiRefT *pRef, DirtyWebApi2PushEventT *pPushEvent)
{
    int32_t iFilterId;

    if (pRef->PushEvents.iEventCount < DIRTY_WEBAPI2_MAX_PUSH_EVENTS)
    {
        //add the new eventType to a filter
        SceNpWebApi2PushEventFilterParameter filterParam;
        ds_memclr(&filterParam, sizeof(filterParam));
        ds_snzprintf(filterParam.dataType.val, SCE_NP_WEBAPI2_PUSH_EVENT_DATA_TYPE_LEN_MAX, pPushEvent->pSceEventDataType);

        if ((iFilterId = sceNpWebApi2PushEventCreateFilter(pRef->iWebApi2CtxId, pRef->PushEvents.iEventHandle, pPushEvent->pNpServiceName, pPushEvent->npServiceLabel, &filterParam, 1)) < 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, sceNpWebApiCreateServicePushEventFilter() failed, (err=%s)\n", pRef, DirtyErrGetName(iFilterId)));
            return (iFilterId);
        }

        //register callbacks for that filter
        for (int32_t iUser = 0; iUser < NETCONN_MAXLOCALUSERS; iUser++)
        {
            SceNpOnlineId onlineId;
            if (NetConnStatus('soid', iUser, &onlineId, sizeof(onlineId)) >= 0)
            {
                if (pPushEvent->pNpServiceName != NULL)
                {
                    if (pPushEvent->Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                    {
                        if ((pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser] = sceNpWebApi2PushEventRegisterCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, iFilterId, _DirtyWebApiCallbackNpWebApi2ServicePushEvent, &pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount])) < 0)
                        {
                            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, sceNpWebApiRegisterPushEventCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser])));
                        }
                    }
                    else if (pPushEvent->Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                    {
                        if ((pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser] = sceNpWebApi2PushEventRegisterPushContextCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, iFilterId, _DirtyWebApiCallbackNpWebApi2ServicePushEventContext, &pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount])) < 0)
                        {
                            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, sceNpWebApi2PushEventRegisterPushContextCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser])));
                        }
                    }
                }
                else
                {
                    if (pPushEvent->Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                    {
                        if ((pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser] = sceNpWebApi2PushEventRegisterCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, iFilterId, _DirtyWebApiCallbackNpWebApi2PushEvent, &pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount])) < 0)
                        {
                            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, sceNpWebApiRegisterPushEventCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser])));
                        }
                    }
                    else if (pPushEvent->Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                    {
                        if ((pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser] = sceNpWebApi2PushEventRegisterPushContextCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, iFilterId, _DirtyWebApiCallbackNpWebApi2PushEventContext, &pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount])) < 0)
                        {
                            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, sceNpWebApi2PushEventRegisterPushContextCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].aCallBackIds[iUser])));
                        }
                    }
                }
            }
        }

        //store off all the state
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].iFilterId = iFilterId;
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].pNpServiceName = pPushEvent->pNpServiceName;
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].npServiceLabel = pPushEvent->npServiceLabel;
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].iRequestId = pPushEvent->iRequestId;
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].pSceEventDataType = pPushEvent->pSceEventDataType;
        pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].pUserData = pPushEvent->pUserData;
        ds_memcpy(&pRef->PushEvents.aEvents[pRef->PushEvents.iEventCount].Callback, &pPushEvent->Callback, sizeof(DirtyWebApi2EventCallbackEntryT));

        pRef->PushEvents.iEventCount++;
    }
    else
    {
        iFilterId = -1;
        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2AddPushEvent, could not add event, no more room.\n", pRef));
    }

    return(iFilterId);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApiRemovePushEventListnenerCommon

    \Description
        Remove an event given the request id and the callback

    \Input *pRef            - module state
    \Input iRequestId       - id returned from DirtyWebApiAddPushEventListener*
    \Input *pCallback       - function to remove

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApiRemovePushEventListnenerCommon(DirtyWebApiRefT *pRef, int32_t iRequestId, DirtyWebApi2EventCallbackT *pCallback)
{
    int32_t iTarget = -1, iResult = 0;

    NetCritEnter(&pRef->DirtyWebApiThreadMutex);
    NetCritEnter(&pRef->crit);

    // find the callback in the list of registered events
    for (int32_t i = 0; i < pRef->PushEvents.iEventCount; ++i)
    {
        if (pRef->PushEvents.aEvents[i].iRequestId == iRequestId)
        {
            uint8_t bMatch = (pCallback->eEventType == DIRTYWEBAPI2_PUSH_EVENT) ? (pRef->PushEvents.aEvents[i].Callback.pPushEventCallback == pCallback->pPushEventCallback) : (pRef->PushEvents.aEvents[i].Callback.pPushEventContextCallback == pCallback->pPushEventContextCallback);

            if (bMatch)
            {
                iTarget = i;
                break;
            }
            else
            {
                NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWevApiRemovePushEventListnenerCommon, iRequestId (%d) and callback pointer (%p) do not match.\n", pRef, iRequestId, pCallback));
                break;
            }
        }
    }

    if (iTarget < 0)
    {
        // not found in the list of registered events
        // but there is still a chance it is about to be registered on the other thread, check for that and remove it if found
        DirtyWebApi2PushEventT *pPushEventRef;
        DirtyWebApi2PushEventT *pPrevPushEventRef = NULL;

        // search for the request in the registration linked list and remove it if we find it
        pPushEventRef = pRef->pPendingPushEvents;
        while (pPushEventRef != NULL)
        {
            if (pPushEventRef->iRequestId == iRequestId)
            {
                uint8_t bMatch = (pCallback->eEventType == DIRTYWEBAPI2_PUSH_EVENT) ? (pPushEventRef->Callback.pPushEventCallback == pCallback->pPushEventCallback) : (pPushEventRef->Callback.pPushEventContextCallback == pCallback->pPushEventContextCallback);

                if (bMatch)
                {
                    // this is the right event, lets remove it before it ever got registered
                    if (pPrevPushEventRef != NULL)
                    {
                        pPrevPushEventRef->pNext = pPushEventRef->pNext; // the node has been removed from the list
                    }
                    else
                    {
                        pRef->pPendingPushEvents = pPushEventRef->pNext;  // this is now the first item in the list (NULL is empty)
                    }
                    DirtyMemFree(pPushEventRef, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
                    iResult = 1;
                    break;
                }
                else
                {
                    NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWevApiRemovePushEventListnenerCommon, iRequestId (%d) and callback pointer (%p) do not match, pre-registration.\n", pRef, iRequestId, pCallback));
                    iResult = -1;
                    break;
                }
            }
            pPrevPushEventRef = pPushEventRef;
            pPushEventRef = pPushEventRef->pNext;
        }
    }
    else
    {
        // still more work to be done, in this case we still need to remove it from sony
        // unregister and clear the sce objects
        for (int32_t iUser = 0; iUser < NETCONN_MAXLOCALUSERS; iUser++)
        {
            iResult = SCE_OK;
            if (pRef->PushEvents.aEvents[iTarget].aCallBackIds[iUser] >= 0)
            {
                if (pRef->PushEvents.aEvents[iTarget].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                {
                    iResult = sceNpWebApi2PushEventUnregisterCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iTarget].aCallBackIds[iUser]);
                }
                else if (pRef->PushEvents.aEvents[iTarget].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                {
                    iResult = sceNpWebApi2PushEventUnregisterPushContextCallback(pRef->webApi2Users[iUser].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iTarget].aCallBackIds[iUser]);
                }
            }

            if (iResult < SCE_OK)
            {
                NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWevApiRemovePushEventListnenerCommon, sceNpWebApiUnregisterExtdPushEventCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(iResult)));
            }
        }

        if (pRef->PushEvents.aEvents[iTarget].iFilterId > 0)
        {
            if ((iResult = sceNpWebApi2PushEventDeleteFilter(pRef->iWebApi2CtxId, pRef->PushEvents.aEvents[iTarget].iFilterId)) != SCE_OK)
            {
                NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWevApiRemovePushEventListnenerCommon, sceNpWebApi2PushEventDeleteFilter() failed, (err=%s)\n", pRef, DirtyErrGetName(iResult)));
            }

            pRef->PushEvents.aEvents[iTarget].iFilterId = -1;
        }

        // move the rest of the array 1 down
        if (iTarget < pRef->PushEvents.iEventCount - 1)
        {
            memmove((void*)&pRef->PushEvents.aEvents[iTarget], (void*)&pRef->PushEvents.aEvents[iTarget + 1], (sizeof(DirtyWebApi2PushEventT) * (pRef->PushEvents.iEventCount - (iTarget + 1))));
        }

        // decrement count
        --pRef->PushEvents.iEventCount;
    }

    NetCritLeave(&pRef->crit);
    NetCritLeave(&pRef->DirtyWebApiThreadMutex);

    return(0);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2InitWebApi

    \Description
        Allocated memory and setup to use the sceNpWebApi*

    \Input *pRef            - pointer to module state
    \Input *pCreateParams   - params

    \Output
        int32_t             - >=0 success, <0 failure

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2InitWebApi(DirtyWebApiRefT *pRef, const DirtyWebApi2CreateParamsT* pCreateParams)
{
    int32_t iRet = 1;
    int32_t iResult;

    if ((pRef->iNetPoolCtxId = DirtyContextManagerCreateNetPoolContext(DIRTY_WEBAPI2_NET_HEAP_NAME, pCreateParams->netHeapSize)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerCreateNetPoolContext() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->iNetPoolCtxId)));
        return(pRef->iNetPoolCtxId);
    }

    if ((pRef->iSslCtxId = DirtyContextManagerCreateSslContext(pCreateParams->sslHeapSize)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerCreateSslContext() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->iSslCtxId)));
        return(pRef->iSslCtxId);
    }

    if ((pRef->iHttp2CtxId = DirtyContextManagerCreateHttp2Context(pRef->iNetPoolCtxId, pRef->iSslCtxId, pCreateParams->uMaxConcurrentRequest)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerCreateHttpContext() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->iHttp2CtxId)));
        return(pRef->iHttp2CtxId);
    }

    if ((iResult = pRef->iWebApi2CtxId = sceNpWebApi2Initialize(pRef->iHttp2CtxId, pCreateParams->webApiHeapSize)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiInitialize() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->iWebApi2CtxId)));
        return(pRef->iWebApi2CtxId);
    }

    if ((pRef->pDirtyWepApiThreadCond = DirtyConditionCreate("WakeupWebApiThread")) == NULL)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] failed to create condition\n", pRef));
        return(-1);
    }

    NetCritInit(&pRef->DirtyWebApiThreadMutex, "WakeupWebApiThreadMutex");

    return(iRet);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2ShutdownWebApi

    \Description
        Free Dirty Session Manager, only gets called by the thread as its terminating.

    \Input *pRef    - pointer to module state

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2ShutdownWebApi(DirtyWebApiRefT *pRef)
{
    int32_t iRet;
    NetPrintf(("dirtywebapi2ps5: [%p] final destruction\n", pRef));

    _DirtyWebApi2CleanupRequestQueue(pRef, -1, -1);

    // release player webapi contexts
    for (int32_t iIndex = 0; iIndex < NETCONN_MAXLOCALUSERS; iIndex++)
    {
        _DirtyWebApi2CleanupWebUserContext(pRef, iIndex);
    }

    if (pRef->iWebApi2CtxId >= 0)
    {
        if ((iRet = sceNpWebApi2Terminate(pRef->iWebApi2CtxId)) != 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiTerminate() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }
    }

    if (pRef->iHttp2CtxId >= 0)
    {
        if ((iRet = DirtyContextManagerFreeHttp2Context(pRef->iHttp2CtxId)) != 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerFreeHttp2Context() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }
    }

    if (pRef->iSslCtxId >= 0)
    {
        if ((iRet = DirtyContextManagerFreeSslContext(pRef->iSslCtxId)) != 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerFreeSslContext() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }
    }

    if (pRef->iNetPoolCtxId >= 0)
    {
        if ((iRet = DirtyContextManagerFreeNetPoolContext(pRef->iNetPoolCtxId)) != 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] DirtyContextManagerFreeNetPoolContext() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }
    }
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2SetupWebUserContext

    \Description
        Prepares a user to use the webapi

    \Input *pRef        - pointer to module state
    \Input iUserIndex   - user index

    \Output
        int32_t         - >=0 success, <0 failure

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2SetupWebUserContext(DirtyWebApiRefT *pRef, int32_t iUserIndex)
{
    SceUserServiceUserId userId;
    int32_t iRet;

    NetCritEnter(&pRef->crit);
    // get the user id for the user at the specified index, and ensure a user is logged in to PSN there
    if ((iRet = userId = NetConnStatus('suid', iUserIndex, NULL, 0)) < 0)
    {
        if (pRef->webApi2Users[iUserIndex].aSceUserId != 0)
        {
            _DirtyWebApi2CleanupWebUserContext(pRef, iUserIndex);
        }
        NetCritLeave(&pRef->crit);
        return(iRet);
    }

    // check to see if this user is already setup with a context
    if (userId != pRef->webApi2Users[iUserIndex].aSceUserId)
    {
        if (pRef->webApi2Users[iUserIndex].aSceUserId != 0)
        {
            _DirtyWebApi2CleanupWebUserContext(pRef, iUserIndex);
        }

        if ((iRet = sceNpWebApi2CreateUserContext(pRef->iWebApi2CtxId, userId)) >= 0)
        {
            //save information about this context
            pRef->webApi2Users[iUserIndex].aSceUserId = userId;
            pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId = iRet;

            //go through the list of events and register this user for them
            for (int32_t iEvent = 0; iEvent < pRef->PushEvents.iEventCount; iEvent++)
            {
                if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                {
                    if ((pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex] = sceNpWebApi2PushEventRegisterCallback(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].iFilterId, _DirtyWebApiCallbackNpWebApi2ServicePushEvent, &pRef->PushEvents.aEvents[iEvent])) < 0)
                    {
                        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2SetupWebUserContext, sceNpWebApiRegisterExtdPushEventCallbackA() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex])));
                    }
                }
                else if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                {
                    if ((pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex] = sceNpWebApi2PushEventRegisterPushContextCallback(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].iFilterId, _DirtyWebApiCallbackNpWebApi2ServicePushEventContext, &pRef->PushEvents.aEvents[iEvent])) < 0)
                    {
                        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2SetupWebUserContext, sceNpWebApi2PushEventRegisterPushContextCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex])));
                    }
                }
            }
        }
        else
        {
            NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiCreateContext() failed for user %d (err=%s)\n", pRef, userId, DirtyErrGetName(iRet)));
        }
    }
    NetCritLeave(&pRef->crit);

    return(iRet);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2CleanupWebUserContext

    \Description
        Stop any web requests and clear state for a given user.

    \Input *pRef        - pointer to module state
    \Input iUserIndex   - user index

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2CleanupWebUserContext(DirtyWebApiRefT *pRef, int32_t iUserIndex)
{
    int32_t iRet;

    if (pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId != 0)
    {
        //go through all the event registrations and unhook the callbacks for this user
        for (int32_t iEvent = 0; iEvent < pRef->PushEvents.iEventCount; iEvent++)
        {
            if (pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex] >= 0)
            {
                if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
                {
                    if ((iRet = sceNpWebApi2PushEventUnregisterCallback(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex])) != SCE_OK)
                    {
                        NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2CleanupWebUserContext, sceNpWebApi2PushEventUnregisterCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
                    }
                }
                else if (pRef->PushEvents.aEvents[iEvent].Callback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
                {
                    if (pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex] >= 0)
                    {
                        if ((iRet = sceNpWebApi2PushEventUnregisterPushContextCallback(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex])) != SCE_OK)
                        {
                            NetPrintf(("dirtywebapi2ps5: [%p] _DirtyWebApi2CleanupWebUserContext, sceNpWebApi2PushEventUnregisterCallback() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
                        }
                    }
                }
            }
            pRef->PushEvents.aEvents[iEvent].aCallBackIds[iUserIndex] = -1;
        }

        sceNpWebApi2DeleteUserContext(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId);
        pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId = 0;
        pRef->webApi2Users[iUserIndex].aSceUserId = 0;
    }
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2PushRequest

    \Description
        Push the request onto the back of the queue.

    \Input *pRef        - pointer to module state
    \Input *pWebRequest - The DirtyWebApi2WebRequestT to push onto the queue

    \Version 05/08/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2PushRequest(DirtyWebApiRefT *pRef, DirtyWebApi2WebRequestT *pWebRequest)
{
    NetCritEnter(&pRef->DirtyWebApiThreadMutex);
    NetCritEnter(&pRef->crit);
    if (pRef->pRequestListFront)
    {
        pWebRequest->pPrev = pRef->pRequestListBack;
        pRef->pRequestListBack->pNext = pWebRequest;
    }
    else
    {
        pRef->pRequestListFront = pWebRequest;
    }
    pRef->pRequestListBack = pWebRequest;
    NetCritLeave(&pRef->crit);

    // signal webapi thread to do work
    if (!DirtyConditionSignal(pRef->pDirtyWepApiThreadCond))
    {
        NetPrintf(("dirtywebapi2ps5: [%p] failed to signal webapi thread.\n", pRef));
    }
    NetCritLeave(&pRef->DirtyWebApiThreadMutex);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2PopRequest

    \Description
        Pop a request from the front of the queue.

    \Input *pRef            - pointer to module state
    \Input iUserIndex       - if >= 0, this function will return the next DirtyWebApi2WebRequestT for the user at the given index. If < 0, the item at the front of the queue is popped.
    \Input iWebRequestId    - if >= 0, this function will return the next DirtyWebApi2WebRequestT that matches the given iWebRequestId. If < 0, the item at the front of the queue is popped.

    \Output
        DirtyWebApi2WebRequestT*  - The next web request, or NULL if queue is empty.  See iUserIndex for further granularity.

    \Version 05/08/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static DirtyWebApi2WebRequestT *_DirtyWebApi2PopRequest(DirtyWebApiRefT *pRef, int32_t iUserIndex, int64_t iWebRequestId)
{
    DirtyWebApi2WebRequestT *pWebRequest;
    NetCritEnter(&pRef->crit);
    pWebRequest = pRef->pRequestListFront;
    while (pWebRequest != NULL)
    {
        if (((iUserIndex < 0) || (pWebRequest->iUserIndex == iUserIndex)) &&
            ((iWebRequestId < 0) || (pWebRequest->iWebRequestId == iWebRequestId)))
        {
            if (pWebRequest->pPrev != NULL)
                pWebRequest->pPrev->pNext = pWebRequest->pNext;
            else
                pRef->pRequestListFront = pWebRequest->pNext;

            if (pWebRequest->pNext != NULL)
                pWebRequest->pNext->pPrev = pWebRequest->pPrev;
            else
                pRef->pRequestListBack = pWebRequest->pPrev;

            pWebRequest->pNext = NULL;
            pWebRequest->pPrev = NULL;
            break;
        }
        pWebRequest = pWebRequest->pNext;
    }
    NetCritLeave(&pRef->crit);
    return pWebRequest;
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2AbortRequest

    \Description
        Stop a particular web request, will NOT evoke completion callback.

    \Input *pRef        - pointer to module state
    \Input *pWebRequest - pointer to request

    \Version 08/19/2013 (cvienneau)
*/
/*************************************************************************************F*/
static void _DirtyWebApi2AbortRequest(DirtyWebApiRefT *pRef, DirtyWebApi2WebRequestT *pWebRequest)
{
    int32_t iRet;
    NetCritEnter(&pRef->crit);
    if ((iRet = sceNpWebApi2AbortRequest(pWebRequest->iWebRequestId)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiAbortRequest() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
    }
    else
    {
        if ((iRet = sceNpWebApi2DeleteRequest(pWebRequest->iWebRequestId)) < 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiDeleteRequest() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }
    }
    NetCritLeave(&pRef->crit);
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2CleanupRequestQueue

    \Description
        Stop any web requests for a given user, will NOT evoke completion callback.

    \Input *pRef            - pointer to module state
    \Input iUserIndex       - user index, if < 0 all users
    \Input iWebRequestId    - iWebRequestid, if < 0 all request under the iUserIndex will be stopped

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2CleanupRequestQueue(DirtyWebApiRefT *pRef, int32_t iUserIndex, int64_t iWebRequestId)
{
    int32_t iCount = 0;
    DirtyWebApi2WebRequestT *pWebRequest;

    NetCritEnter(&pRef->crit);

    //clear the queue
    while ((pWebRequest = _DirtyWebApi2PopRequest(pRef, iUserIndex, iWebRequestId)) != NULL)
    {
        _DirtyWebApi2AbortRequest(pRef, pWebRequest);
        ++iCount;
    }

    //do the current request
    if ((pRef->pCurrentWebRequest != NULL) &&
    ((iWebRequestId < 0) || (pRef->pCurrentWebRequest->iWebRequestId == iWebRequestId)))
    {
        _DirtyWebApi2AbortRequest(pRef, pRef->pCurrentWebRequest);
        NetCritEnter(&pRef->requestCrit);
        pRef->pCurrentWebRequest = NULL;                                    // Set it to NULL actually signals the _DirtyWebApi2Thread dont do callback.
        NetCritLeave(&pRef->requestCrit);
        ++iCount;
        NetPrintf(("dirtywebapi2ps5: [%p] aborted %d requests including one active.\n", pRef, iCount));
    }
    else if (iCount > 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] aborted %d requests.\n", pRef, iCount));
    }

    NetCritLeave(&pRef->crit);
    return iCount;
}

/*F*************************************************************************************/
/*!
    \Function    _DirtyWebApi2ReadResponseData

    \Description
        Read any incoming data from the specified request into the supplied buffer

    \Input *pRef        - pointer to module state
    \Input requestId    - id generated by sceNpWebApiCreateRequest
    \Input *pReadBuff   - pointer data will be written too
    \Input iBuffSize    - size of pReadBuff
    \Input *pReadSize   - output for the number of bytes read in this call

    \Output
        int32_t             - >=0 success, <0 failure

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************F*/
static int32_t _DirtyWebApi2ReadResponseData(DirtyWebApiRefT *pRef, int64_t requestId, char *pReadBuff, int32_t iBuffSize, int32_t *pReadSize)
{
    int32_t iRet;
    size_t iReadSize = 0;

    do
    {
        iRet = sceNpWebApi2ReadData(requestId, pReadBuff + iReadSize, iBuffSize - iReadSize);
        if (iRet < 0)
        {
            NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiReadData() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
            return(iRet);
        }
        iReadSize += iRet;
    } while (iRet > 0);

    if (pReadSize != NULL)
    {
        *pReadSize = iReadSize;
    }
    return(iRet);
}

/*F*************************************************************************************************/
/*!
    \Function _DirtyWebApiProcessRequestCallback

    \Description
        Processes queued request callback

    \Input *pRef                     - module state
    \Input *pRequestCallbackEntry    - request callback entry

    \Notes
        Should only be called when the when 'qcal' is true

    \Version 07/21/2020 (tcho)
*/
/*************************************************************************************************F*/
static void _DirtyWebApi2ProcessRequestCallback(DirtyWebApiRefT *pRef, DirtyWebApi2RequestCallbackEntryT *pRequestCallbackEntry)
{
    pRequestCallbackEntry->pCallback(pRequestCallbackEntry->iSceError, pRequestCallbackEntry->iUserIndex, pRequestCallbackEntry->iStatusCode, pRequestCallbackEntry->pRespBody, pRequestCallbackEntry->iRespBodyLength, pRequestCallbackEntry->pUserData);
    DirtyMemFree(pRequestCallbackEntry->pRespBody, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
}

/*F*************************************************************************************************/
/*!
    \Function _DirtyWebApiProcessEventCallback

    \Description
        Processes queued event callback

    \Input *pRef                   - module state
    \Input *pEventCallbackEntry    - event callback entry

    \Notes
        Should only be called when the when 'qcal' is true

    \Version 07/21/2020 (tcho)
*/
/*************************************************************************************************F*/
static void _DirtyWebApi2ProcessEventCallback(DirtyWebApiRefT *pRef, DirtyWebApi2EventCallbackEntryT *pEventCallbackEntry)
{
    if (pEventCallbackEntry->EventCallback.eEventType == DIRTYWEBAPI2_PUSH_EVENT)
    {
        pEventCallbackEntry->EventCallback.pPushEventCallback(pEventCallbackEntry->iUserCtxId, pEventCallbackEntry->iCallbackId,
            pEventCallbackEntry->pNpServiceName, pEventCallbackEntry->ServiceLabel, &pEventCallbackEntry->To, &pEventCallbackEntry->From,
            &pEventCallbackEntry->EventDataType, pEventCallbackEntry->pData, pEventCallbackEntry->sDataLen, pEventCallbackEntry->pUserArg);
    }
    else if (pEventCallbackEntry->EventCallback.eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
    {
        pEventCallbackEntry->EventCallback.pPushEventContextCallback(pEventCallbackEntry->iUserCtxId, pEventCallbackEntry->iCallbackId,
            &pEventCallbackEntry->PushContextId, pEventCallbackEntry->PushConextCallbackType, pEventCallbackEntry->pNpServiceName,
            pEventCallbackEntry->ServiceLabel, &pEventCallbackEntry->To, &pEventCallbackEntry->From, &pEventCallbackEntry->EventDataType,
            pEventCallbackEntry->pData, pEventCallbackEntry->sDataLen, pEventCallbackEntry->pUserArg);
    }

    DirtyMemFree(pEventCallbackEntry->pData, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
    DirtyMemFree(pEventCallbackEntry->pNpServiceName, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
}



/*F********************************************************************************/
/*!
    \Function    _DirtyWebApi2AddEventCalbackToQueue

    \Description
        Add a event callback to the callback queue if queuing of callbacks is enbled.
        If not it will directly initiate the callback

    \Input  *pRef           - pointer to module state
    \Input  eEventType      - event type
    \Input  iUserCtxId      - user context id
    \Input  iCallbackId     - callback id
    \Input  *pPushCtxId     - push context id
    \Input  cbType          - push event context callback type
    \Input  *pNpServiceName - NP service name
    \Input  npServiceLabel  - NP service label
    \Input  *pTo            - contains the account id of target user
    \Input  *pFrom          - contains the account id of source user
    \Input  *pDataType      - push event datatype
    \Input  *pData          - data pointer
    \Input  *dataLen        - data len
    \Input  *pUserData      - DirtyWebApi2PushEventT struct

    \Version 07/21/2020 (tcho)
*/
/********************************************************************************F*/
static void _DirtyWebApi2AddEventCalbackToQueue(DirtyWebApiRefT *pRef, DirtyWebApi2EventTypeE eEventType, int32_t iUserCtxId, int32_t iCallbackId, const SceNpWebApi2PushEventPushContextId *pPushCtxId,
    SceNpWebApi2PushEventPushContextCallbackType cbType, const char *pNpServiceName, SceNpServiceLabel npServiceLabel, const SceNpPeerAddressA *pTo, const SceNpPeerAddressA *pFrom,
    const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen, void *pUserArg)
{
    DirtyWebApi2PushEventT *pEvent = (DirtyWebApi2PushEventT *)pUserArg;

    if (pRef->bQueueCallback == TRUE)
    {
        // add an entry to the callback queue
        DirtyWebApi2CallbackEntryT *pCallbackEntry;

        if ((pCallbackEntry = (DirtyWebApi2CallbackEntryT *)DirtyMemAlloc(sizeof(*pCallbackEntry), DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData)) == NULL)
        {
            NetPrintf(("dirtywebapi2ps5: cannot allocate memory for a event callback entry\n"));
            return;
        }

        if (pNpServiceName != NULL)
        {
            if ((pCallbackEntry->EventCallbackEntry.pNpServiceName = (char *)DirtyMemAlloc(strlen(pNpServiceName) + 1, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData)) == NULL)
            {
                NetPrintf(("dirtywebapi2ps5: cannot allocate memory for Np Service Name\n"));
                DirtyMemFree(pCallbackEntry, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
                return;
            }

            ds_memcpy(pCallbackEntry->EventCallbackEntry.pNpServiceName, pNpServiceName, strlen(pNpServiceName) + 1);
        }

        if ((pCallbackEntry->EventCallbackEntry.pData = (char *)DirtyMemAlloc(dataLen, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData)) == NULL)
        {
            NetPrintf(("dirtywebapi2ps5: cannot allocate memory for event data\n"));
            DirtyMemFree(pCallbackEntry->EventCallbackEntry.pNpServiceName, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            DirtyMemFree(pCallbackEntry, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            return;
        }

        ds_memclr(pCallbackEntry, sizeof(DirtyWebApi2CallbackEntryT));
        pCallbackEntry->EventCallbackEntry.EventCallback.eEventType = eEventType;
        pCallbackEntry->EventCallbackEntry.iUserCtxId = iUserCtxId;
        pCallbackEntry->EventCallbackEntry.iCallbackId = iCallbackId;
        pCallbackEntry->EventCallbackEntry.ServiceLabel = npServiceLabel;
        pCallbackEntry->EventCallbackEntry.pUserArg = pEvent->pUserData;

        ds_memcpy(&pCallbackEntry->EventCallbackEntry.To, pTo, sizeof(SceNpPeerAddressA));
        if (pFrom != NULL)
        {
            ds_memcpy(&pCallbackEntry->EventCallbackEntry.From, pFrom, sizeof(SceNpPeerAddressA));
        }
        ds_memcpy(pCallbackEntry->EventCallbackEntry.pData, pData, dataLen);

        if (eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
        {
            pCallbackEntry->EventCallbackEntry.PushConextCallbackType = cbType;
            pCallbackEntry->EventCallbackEntry.EventCallback.pPushEventContextCallback = pEvent->Callback.pPushEventContextCallback;
            ds_memcpy(&pCallbackEntry->EventCallbackEntry.PushContextId, pPushCtxId, sizeof(SceNpWebApi2PushEventPushContextId));
        }
        else if (eEventType == DIRTYWEBAPI2_PUSH_EVENT)
        {
            pCallbackEntry->EventCallbackEntry.EventCallback.pPushEventCallback = pEvent->Callback.pPushEventCallback;
        }

        NetCritEnter(&pRef->requestCrit);

        // add the list to the back of the queue
        if (pRef->pCallbackListBack == NULL)
        {
            if (pRef->pCallbackListFront != NULL)
            {
                pRef->pCallbackListFront->pNext = pCallbackEntry;
            }
            else
            {
                pRef->pCallbackListFront = pCallbackEntry;
            }
        }
        else
        {
            pRef->pCallbackListBack->pNext = pCallbackEntry;
        }

        pRef->pCallbackListBack = pCallbackEntry;
        NetCritLeave(&pRef->requestCrit);
    }
    else
    {
        if (eEventType == DIRTYWEBAPI2_PUSH_EVENT)
        {
            pEvent->Callback.pPushEventCallback(iUserCtxId, iCallbackId, pNpServiceName, npServiceLabel, pTo, pFrom, pDataType, pData, dataLen, pEvent->pUserData);
        }
        else if (eEventType == DIRTYWEBAPI2_PUSH_EVENT_CONTEXT)
        {
            pEvent->Callback.pPushEventContextCallback(iUserCtxId, iCallbackId, pPushCtxId, cbType, pNpServiceName, npServiceLabel, pTo, pFrom, pDataType, pData, dataLen, pEvent->pUserData);
        }
    }
}
/*F********************************************************************************/
/*!
    \Function    _DirtyWebApi2AddRequestCallbackToQueue

    \Description
        Add a request callback to the callback queue if queuing of callbacks is enbled.
        If not it will directly initiate the callback

    \Input  *pRef           - pointer to module state
    \Input  *pCallback      - pointer to DirtyWebApiCallbackT
    \Input  iSceError       - sce error
    \Input  iUserIndex      - user index
    \Input  iStatusCode     - status code
    \Input  pRespBody       - response body
    \Input  iRespBodyLength - response body length
    \Input  *pUserData      - user data

    \Version 07/21/2020 (tcho)
*/
/********************************************************************************F*/
static void _DirtyWebApi2AddRequestCallbackToQueue(DirtyWebApiRefT *pRef, DirtyWebApiCallbackT *pCallback, int32_t iSceError, int32_t iUserIndex, int32_t iStatusCode, const char *pRespBody, int32_t iRespBodyLength, void *pUserData)
{
    if (pRef->bQueueCallback == TRUE)
    {
        // add an entry to the callback queue
        DirtyWebApi2CallbackEntryT *pCallbackEntry = (DirtyWebApi2CallbackEntryT *)DirtyMemAlloc(sizeof(*pCallbackEntry), DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);

        if (pCallbackEntry != NULL)
        {
            DirtyWebApi2RequestCallbackEntryT *pRequestCallbackEntry = &pCallbackEntry->RequestCallbackEntry;

            ds_memclr(pCallbackEntry, sizeof(*pCallbackEntry));
            pCallbackEntry->eCallbackType = DIRTYWEBAPI2_REQUEST_CALLBACK;

            pRequestCallbackEntry->pCallback = pCallback;
            pRequestCallbackEntry->iSceError = iSceError;
            pRequestCallbackEntry->iUserIndex = iUserIndex;
            pRequestCallbackEntry->iStatusCode = iStatusCode;
            pRequestCallbackEntry->iRespBodyLength = iRespBodyLength;
            pRequestCallbackEntry->pUserData = pUserData;
            pRequestCallbackEntry->pRespBody = (char *)DirtyMemAlloc(iRespBodyLength, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);

            if (pRequestCallbackEntry->pRespBody != NULL)
            {
                ds_memcpy(pRequestCallbackEntry->pRespBody, pRespBody, iRespBodyLength);
            }
            else
            {
                NetPrintf(("dirtywebapi2: _DirtyWebApi2AddRequestCallbackToQueue() cannot allocate memory for response\n"));
                DirtyMemFree(pCallbackEntry, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
                return;
            }

            if (pRef->pCallbackListBack == NULL)
            {
                if (pRef->pCallbackListFront != NULL)
                {
                    pRef->pCallbackListFront->pNext = pCallbackEntry;
                }
                else
                {
                    pRef->pCallbackListFront = pCallbackEntry;
                }
            }
            else
            {
                pRef->pCallbackListBack->pNext = pCallbackEntry;
            }

            pRef->pCallbackListBack = pCallbackEntry;
        }
    }
    else
    {
        // if we dont need to queue to the callback just call it
        pCallback(iSceError, iUserIndex, iStatusCode, pRespBody, iRespBodyLength, pUserData);
    }
}

/*F********************************************************************************/
/*!
    \Function    _DirtyWebApi2ClearCallbackQueue

    \Description
        clears the callback queue

    \Input  *pRef           - module state

    \Version 07/23/2020 (tcho)
*/
/********************************************************************************F*/
static void _DirtyWebApi2ClearCallbackQueue(DirtyWebApiRefT *pRef)
{
    NetCritEnter(&pRef->requestCrit);

    DirtyWebApi2CallbackEntryT *pCallbackEntry = pRef->pCallbackListFront;
    while (pCallbackEntry != NULL)
    {
        DirtyWebApi2CallbackEntryT *pTempCallbackEntry;

        if (pCallbackEntry->eCallbackType == DIRTYWEBAPI2_REQUEST_CALLBACK)
        {
            DirtyMemFree(pCallbackEntry->RequestCallbackEntry.pRespBody, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
        }
        else if (pCallbackEntry->eCallbackType == DIRTYWEBAPI2_EVENT_CALLBACK)
        {
            DirtyMemFree(pCallbackEntry->EventCallbackEntry.pData, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            DirtyMemFree(pCallbackEntry->EventCallbackEntry.pNpServiceName, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
        }

        pTempCallbackEntry = pCallbackEntry;
        pCallbackEntry = pCallbackEntry->pNext;
        DirtyMemFree(pTempCallbackEntry, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
    }

    NetCritLeave(&pRef->requestCrit);
}

/*F********************************************************************************/
/*!
    \Function    _DirtyWebApi2Update

    \Description
        Service webapi requests.

    \Input  *pData    - pointer to DirtyWebApiRefT module state
    \Input  uTick     - time tick

    \Version 02/03/2015 (tcho)
*/
/********************************************************************************F*/
static void _DirtyWebApi2Update(void *pData, uint32_t uTick)
{
    DirtyWebApiRefT *pRef = (DirtyWebApiRefT *)pData;
    if (pRef->bAutoUpdate)
    {
        DirtyWebApiUpdate(pRef);
    }
}

/*F********************************************************************************/
/*!
    \Function    _DirtyWebApi2Thread

    \Description
        Service webapi requests.

    \Input  *pArg    - pointer to DirtyWebApiRefT module state

    \Version 05/09/2013 (mcorcoran)
*/
/********************************************************************************F*/
static void _DirtyWebApi2Thread(void *pArg)
{
    DirtyWebApiRefT *pRef = (DirtyWebApiRefT *)pArg;
    int32_t iRet = 0, iStatusCode = 0, iBytesRead;
    char strThreadId[32];

    // get the thread id
    DirtyThreadGetThreadId(strThreadId, sizeof(strThreadId));

    NetPrintf(("dirtywebapi2ps5: [%p] Thread starts (thread id = %s)\n", pRef, strThreadId));

    while (pRef->iThreadLife == 1)
    {
        // wait for the condition variable to be signaled if there are no pending work to be done
        NetCritEnter(&pRef->DirtyWebApiThreadMutex);
        while ((pRef->pRequestListFront == NULL) && (pRef->pPendingPushEvents == NULL) && (pRef->iThreadLife == 1))
        {
            DirtyConditionWait(pRef->pDirtyWepApiThreadCond, &pRef->DirtyWebApiThreadMutex);
        }
        NetCritLeave(&pRef->DirtyWebApiThreadMutex);

        // check to be sure all users are setup, so that they have events registered
        NetCritEnter(&pRef->crit);
        for (int32_t iUser = 0; iUser < NETCONN_MAXLOCALUSERS; iUser++)
        {
            _DirtyWebApi2SetupWebUserContext(pRef, iUser);
        }

        pRef->pCurrentWebRequest = _DirtyWebApi2PopRequest(pRef, -1, -1);
        DirtyWebApi2WebRequestT * pCurrentWebRequestLocal = pRef->pCurrentWebRequest;     // keep a reference to avoid set to NULL by another thread. We are about to leave the lock protected area.

        // this could take a long time we are doing one push event add every tick
        DirtyWebApi2PushEventT * pPushEventRef = pRef->pPendingPushEvents;
        DirtyWebApi2PushEventT currentPushEvent;

        if (pPushEventRef != NULL)
        {
            ds_memcpy_s(&currentPushEvent, sizeof(currentPushEvent), pPushEventRef, sizeof(*pPushEventRef));
            pRef->pPendingPushEvents = pPushEventRef->pNext;
            DirtyMemFree(pPushEventRef, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            _DirtyWebApi2AddPushEvent(pRef, &currentPushEvent);
        }

        NetCritLeave(&pRef->crit);

        if (pCurrentWebRequestLocal == NULL)
        {
            continue;
        }

        SceNpWebApi2ResponseInformationOption respInfoOption;
        char strError[DIRTY_WEBAPI2_ERROR_BUFFER_SIZE];
        ds_memclr(&respInfoOption, sizeof(respInfoOption));
        ds_memclr(strError, sizeof(strError));
        respInfoOption.pErrorObject = strError;
        respInfoOption.errorObjectSize = sizeof(strError);

        if ((iRet = sceNpWebApi2SendRequest(
            pCurrentWebRequestLocal->iWebRequestId,
            (pCurrentWebRequestLocal->iContentLength ? &pCurrentWebRequestLocal->pContent[0] : NULL),
            pCurrentWebRequestLocal->iContentLength, &respInfoOption)) >= 0)
        {
            // store http status code
            iStatusCode = respInfoOption.httpStatus;

            //we don't want to use our normal critical section since that will 'more' likely lead to deadlock
            NetCritEnter(&pRef->requestCrit);

            // attempt to read the data, again long blocking (save one byte to safely null terminate)
            if ((iRet = _DirtyWebApi2ReadResponseData(pRef, pCurrentWebRequestLocal->iWebRequestId, pRef->aReadBuffer, pRef->uReadBufferSize - 1, &iBytesRead)) >= 0)
            {
                //a convenience for strings
                pRef->aReadBuffer[iBytesRead] = '\0';

                if (pRef->pCurrentWebRequest != NULL)
                {
                    _DirtyWebApi2AddRequestCallbackToQueue(pRef, pRef->pCurrentWebRequest->pCallback, SCE_OK, pRef->pCurrentWebRequest->iUserIndex, iStatusCode, (iBytesRead ? pRef->aReadBuffer : NULL), iBytesRead, pRef->pCurrentWebRequest->pUserData);
                }
            }
            NetCritLeave(&pRef->requestCrit);
        }
        else
        {
            NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiSendRequest2() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
        }

        NetCritEnter(&pRef->requestCrit);
        if ((pRef->pCurrentWebRequest != NULL) && (iRet != SCE_NP_WEBAPI2_ERROR_ABORTED))
        {
            //callback for failed requets, so the user has a chance to cleanup
            if (iRet < 0)
            {
                _DirtyWebApi2AddRequestCallbackToQueue(pRef, pRef->pCurrentWebRequest->pCallback, iRet, pRef->pCurrentWebRequest->iUserIndex, iStatusCode, NULL, 0, pRef->pCurrentWebRequest->pUserData);
            }

            // delete the request
            if ((iRet = sceNpWebApi2DeleteRequest(pRef->pCurrentWebRequest->iWebRequestId)) < 0)
            {
                NetPrintf(("dirtywebapi2ps5: [%p] sceNpWebApiDeleteRequest() failed, (err=%s)\n", pRef, DirtyErrGetName(iRet)));
            }

            // free the memory
            DirtyMemFree(pRef->pCurrentWebRequest, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            pRef->pCurrentWebRequest = NULL;
        }
        NetCritLeave(&pRef->requestCrit);
    }

    NetPrintf(("dirtywebapi2ps5: [%p] Thread exit (thread id = %s)\n", pRef, strThreadId));
    pRef->iThreadLife = 0;
}

/*** Public Functions ******************************************************************/

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiCreate

    \Description
        Allocate module state and prepare for use.

    \Input  pCreateParams - creation parameters as per user preference

    \Output
        DirtyWebApiRefT *   - reference pointer (must be passed to all other functions)

    \Version 09/06/2013 (abaldeva)
*/
/*************************************************************************************************F*/
DirtyWebApiRefT *DirtyWebApiCreate(const DirtyWebApi2CreateParamsT* pCreateParams)
{
    DirtyWebApiRefT *pRef;
    DirtyThreadConfigT ThreadConfig;
    int32_t iMemGroup, iResult;
    void *pMemGroupUserData;
    DirtyWebApi2CreateParamsT createParamsLocal;
    int32_t iNetHeapSize = 0;

    if (pCreateParams)
    {
        createParamsLocal = *pCreateParams;
    }
    else
    {
        ds_memclr(&createParamsLocal, sizeof(createParamsLocal));
    }

    // net heap size depends on the maximum number of net context shares
    iNetHeapSize = DIRTY_WEBAPI2_NET_HEAP_SIZE * DirtyContextManagerStatus('mncs', 0, NULL, 0);

    createParamsLocal.netHeapSize = (createParamsLocal.netHeapSize == 0) ? iNetHeapSize : createParamsLocal.netHeapSize;
    createParamsLocal.sslHeapSize = (createParamsLocal.sslHeapSize == 0) ? DIRTY_WEBAPI2_SSL_HEAP_SIZE : createParamsLocal.sslHeapSize;
    createParamsLocal.webApiHeapSize = (createParamsLocal.webApiHeapSize == 0) ? DIRTY_WEBAPI2_HEAP_SIZE : createParamsLocal.webApiHeapSize;
    createParamsLocal.readBufferSize = (createParamsLocal.readBufferSize == 0) ? DIRTY_WEBAPI2_READ_BUFFER_SIZE : createParamsLocal.readBufferSize;
    createParamsLocal.uMaxConcurrentRequest = (createParamsLocal.uMaxConcurrentRequest <= DIRTY_WEBAPI2_CONCURRENT_REQUEST) ? DIRTY_WEBAPI2_CONCURRENT_REQUEST : createParamsLocal.uMaxConcurrentRequest;
    DirtyMemGroupQuery(&iMemGroup, &pMemGroupUserData);

    // allocate and init module state
    if ((pRef = (DirtyWebApiRefT*)DirtyMemAlloc(sizeof(*pRef), DIRTYWEBAPI_MEMID, iMemGroup, pMemGroupUserData)) == NULL)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] failed to allocate module state.\n", pRef));
        return(NULL);
    }
    ds_memclr(pRef, sizeof(*pRef));
    pRef->iMemGroup = iMemGroup;
    pRef->pMemGroupUserData = pMemGroupUserData;
    pRef->uReadBufferSize = createParamsLocal.readBufferSize;
    pRef->bQueueCallback = FALSE;

    if ((pRef->aReadBuffer = (char*)DirtyMemAlloc(pRef->uReadBufferSize, DIRTYWEBAPI_MEMID, iMemGroup, pMemGroupUserData)) == NULL)
    {
        DirtyMemFree(pRef, DIRTYWEBAPI_MEMID, iMemGroup, pMemGroupUserData);
        NetPrintf(("dirtywebapi2ps5: [%p] failed to allocate read buffer.\n", pRef));
        return(NULL);
    }

    NetCritInit(&pRef->crit, DIRTY_WEBAPI2_NET_HEAP_NAME);
    NetCritInit(&pRef->requestCrit, DIRTY_WEBAPI2_NET_HEAP_NAME);

    // prepare web api
    if (_DirtyWebApi2InitWebApi(pRef, &createParamsLocal) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: failed to initialize Np WebApi\n"));
        DirtyWebApiDestroy(pRef);
        return(NULL);
    }

    // configure thread parameters
    ds_memclr(&ThreadConfig, sizeof(ThreadConfig));
    ThreadConfig.pName = "WebApi";
    /* if netconn has not been created 'affn' selector will return an error
       in this case we will just use the default thread affinity passed in through the create params
    */
    if ((ThreadConfig.iAffinity = NetConnStatus('affn', 0, NULL, 0)) < 0)
    {
        ThreadConfig.iAffinity = createParamsLocal.uThreadCpuAffinity;
    }

    ThreadConfig.iVerbosity = 1;
    pRef->iThreadLife = 1;

    //start a thread to service webapi
    if ((iResult = DirtyThreadCreate(_DirtyWebApi2Thread, pRef, &ThreadConfig)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] unable to create web api thread (err=%d)\n", pRef, iResult));
        pRef->iThreadLife = 0;
        DirtyWebApiDestroy(pRef);
        return(NULL);
    }

    //setup initial state for push events
    _DirtyWebApi2InitPushEvents(pRef);

    // add _DirtyWebApi2Update to netconn idler
    NetConnIdleAdd(_DirtyWebApi2Update, pRef);
    pRef->bAutoUpdate = TRUE;

    NetPrintf(("dirtywebapi2ps5: [%p] initial creation completed.\n", pRef));

    // return ref to caller
    return(pRef);
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiDestroy

    \Description
        Destroy the module and release its state

    \Input *pRef    - reference pointer

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************************F*/
void DirtyWebApiDestroy(DirtyWebApiRefT *pRef)
{
    NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiDestroy initiated\n", pRef));

    // signal thread to shutdown (if running)
    if (pRef->iThreadLife == 1)
    {
        NetCritEnter(&pRef->DirtyWebApiThreadMutex);
        pRef->iThreadLife = 2;

        // signal webapi thread to do work
        if (!DirtyConditionSignal(pRef->pDirtyWepApiThreadCond))
        {
            NetPrintf(("dirtywebapi2ps5: [%p] failed to signal webapi thread.\n", pRef));
        }
        NetCritLeave(&pRef->DirtyWebApiThreadMutex);

        while (pRef->iThreadLife > 0)
        {
            sceKernelUsleep(1);
        }
    }

    NetConnIdleDel(_DirtyWebApi2Update, pRef);
    _DirtyWebApi2DestroyPushEvents(pRef);
    _DirtyWebApi2ShutdownWebApi(pRef);

    if (pRef->pDirtyWepApiThreadCond != NULL)
    {
        DirtyConditionDestroy(pRef->pDirtyWepApiThreadCond);
        pRef->pDirtyWepApiThreadCond = NULL;
        NetCritKill(&pRef->DirtyWebApiThreadMutex);
    }

    _DirtyWebApi2ClearCallbackQueue(pRef);

    NetCritKill(&pRef->crit);
    NetCritKill(&pRef->requestCrit);
    DirtyMemFree(pRef->aReadBuffer, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
    DirtyMemFree(pRef, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
}

/*F*************************************************************************************************/
/*!
    \Function DirtyWebApiUpdate

    \Description
        Gives the dirtywebapi module time to process requests

    \Input *pRef    - reference pointer

    \Notes
        Should only be called when the 'auto' control is disabled

    \Version 07/20/2020 (eesponda)
*/
/*************************************************************************************************F*/
void DirtyWebApiUpdate(DirtyWebApiRefT *pRef)
{
    if (pRef->pCallbackListBack != NULL)
    {
        if (NetCritTry(&pRef->crit))
        {
            if (NetCritTry(&pRef->requestCrit))
            {
                DirtyWebApi2CallbackEntryT *pCallbackEntry = pRef->pCallbackListFront;

                while (pCallbackEntry != NULL)
                {
                    if (pCallbackEntry->eCallbackType == DIRTYWEBAPI2_REQUEST_CALLBACK)
                    {
                        // process request Callback
                        _DirtyWebApi2ProcessRequestCallback(pRef, &pCallbackEntry->RequestCallbackEntry);
                    }
                    else if (pCallbackEntry->eCallbackType == DIRTYWEBAPI2_EVENT_CALLBACK)
                    {
                        // process event callback
                        _DirtyWebApi2ProcessEventCallback(pRef, &pCallbackEntry->EventCallbackEntry);
                    }

                    // remove processed entry
                    pRef->pCallbackListFront = pCallbackEntry->pNext;
                    DirtyMemFree(pCallbackEntry, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
                    pCallbackEntry = pRef->pCallbackListFront;

                    // we reach the end of the list
                    if (pRef->pCallbackListFront == NULL)
                    {
                        pRef->pCallbackListBack = NULL;
                    }
                }

                NetCritLeave(&pRef->requestCrit);
            }

            NetCritLeave(&pRef->crit);
        }
    }
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiRequestEx

    \Description
        Submit a WebApi request with additional request headers

    \Input *pRef           - reference pointer
    \Input  iUserIndex     - user index
    \Input *pApiGroup      - SCE API group
    \Input  eHttpMethod    - SCE HTTP2 method
    \Input *pPath          - the URI path to request
    \Input *pContent       - body content to be sent along with the HTTP request (e.g. POST or PUT requests)
    \Input *iContentLength - context length
    \Input *pContentType   - context type
    \Input *pReqHeaders    - CRLF delimit resquest headers and values  "key-1:value-1\r\nkey-2:value-2\r\n......"
    \Input *pCallback      - callback pointer
    \Input *pUserData      - user data

    \Output
        int64_t    - positive request id on success, else negative=error

    \Version 11/08/2019 (tcho)
*/
/*************************************************************************************************F*/
int64_t DirtyWebApiRequestEx(DirtyWebApiRefT *pRef, int32_t iUserIndex, const char *pApiGroup, SceNpWebApi2HttpMethod eHttpMethod, const char *pPath, const uint8_t *pContent, int32_t iContentLength, const char *pContentType, const char *pReqHeaders, DirtyWebApiCallbackT *pCallback, void *pUserData)
{
    NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiRequestEx: pApiGroup: [%s] pPath [%s]\n", pRef, pApiGroup, pPath));
    int32_t iResult;
    int64_t iWebRequestId;

    if ((iResult = _DirtyWebApi2SetupWebUserContext(pRef, iUserIndex)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] No valid user web context for user: %d\n", pRef, iUserIndex));
        return(-1);
    }

    SceNpWebApi2ContentParameter aContentParameter;
    if (iContentLength)
    {
        aContentParameter.contentLength = iContentLength;
        aContentParameter.pContentType = pContentType;
    }

    if ((iResult = sceNpWebApi2CreateRequest(
        pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId,
        pApiGroup,
        pPath,
        eHttpMethod,
        (iContentLength ? &aContentParameter : NULL),
        &iWebRequestId)) == SCE_OK)
    {
        // add http request header if any
        if (pReqHeaders != NULL)
        {
            char strName[256];
            char strValue[1024 * 4];

            for (; ProtoHttpGetNextHeader(NULL, pReqHeaders, strName, sizeof(strName), strValue, sizeof(strValue), &pReqHeaders) == 0; )
            {
                if ((iResult = sceNpWebApi2AddHttpRequestHeader(iWebRequestId, strName, strValue)) != SCE_OK)
                {
                    NetPrintf(("dirtywebapi2ps5: could not add NpWebApi request header\n"));
                    sceNpWebApi2DeleteRequest(iWebRequestId);
                    return(iResult);
                }
            }
        }

        DirtyWebApi2WebRequestT *pWebRequest;
        if ((pWebRequest = (DirtyWebApi2WebRequestT*)DirtyMemAlloc(sizeof(DirtyWebApi2WebRequestT) + iContentLength, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData)) == NULL)
        {
            NetPrintf(("dirtywebapi2ps5: could not allocate memory for DirtyWebApi2WebRequestT\n"));
            return(-1);
        }

        ds_memclr(pWebRequest, sizeof(DirtyWebApi2WebRequestT));

        pWebRequest->iUserIndex = iUserIndex;
        pWebRequest->pCallback = pCallback;
        pWebRequest->pUserData = pUserData;
        pWebRequest->iWebRequestId = iWebRequestId;
        if (iContentLength)
        {
            pWebRequest->iContentLength = iContentLength;
            ds_memcpy(&pWebRequest->pContent[0], pContent, pWebRequest->iContentLength);
        }

        _DirtyWebApi2PushRequest(pRef, pWebRequest);
        return(iWebRequestId);
    }

    return(iResult);
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiRequest

    \Description
        Destroy the module and release its state

    \Input *pRef           - reference pointer
    \Input  iUserIndex     - user index
    \Input *pApiGroup      - SCE API group
    \Input  eHttpMethod    - SCE HTTP2 method
    \Input *pPath          - the URI path to request
    \Input *pContent       - body content to be sent along with the HTTP request (e.g. POST or PUT requests)
    \Input *iContentLength - context length
    \Input *pContentType   - context type
    \Input *pCallback      - callback pointer
    \Input *pUserData      - user data

    \Output
        int64_t    - positive request id on success, else negative=error

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************************F*/
int64_t DirtyWebApiRequest(DirtyWebApiRefT *pRef, int32_t iUserIndex, const char *pApiGroup, SceNpWebApi2HttpMethod eHttpMethod, const char *pPath, const uint8_t *pContent, int32_t iContentLength, const char *pContentType, DirtyWebApiCallbackT *pCallback, void *pUserData)
{
    return(DirtyWebApiRequestEx(pRef, iUserIndex, pApiGroup, eHttpMethod, pPath, pContent, iContentLength, pContentType, NULL, pCallback, pUserData));
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiAbortRequestById

    \Description

    Stop a specific request given its request id

    \Input *pRef            - pointer to module state
    \Input iUserIndex       - user index -1 if we only want to match by request id
    \Input iWebRequestId    - web request id to be aborted

    \Output
        int32_t    - 0 on success, negative=error

    \Version 04/24/2020 (tcho)
*/
/*************************************************************************************************F*/
int32_t DirtyWebApiAbortRequestById(DirtyWebApiRefT *pRef, int32_t iUserIndex,  int64_t iWebRequestId)
{
    return(_DirtyWebApi2CleanupRequestQueue(pRef, iUserIndex, iWebRequestId));
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiAbortRequests

    \Description
        Stop any web requests for a given user, will NOT evoke completion callback.
        Not to be called from a completion callback.

    \Input *pRef        - pointer to module state
    \Input iUserIndex   - user index, if < 0 all users

    \Output
        int32_t    - negative=error, else the number of requests aborted

    \Version 05/09/2013 (mcorcoran)
*/
/*************************************************************************************************F*/
int32_t DirtyWebApiAbortRequests(DirtyWebApiRefT *pRef, int32_t iUserIndex)
{
    if ((iUserIndex < -1) || (iUserIndex >= NETCONN_MAXLOCALUSERS))
    {
        NetPrintf(("dirtywebapi2ps5: [%p] iUserIndex(%d) is not a valid user index\n", iUserIndex));
        return(-1);
    }

    return(DirtyWebApiAbortRequestById(pRef, iUserIndex, -1));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiAddPushEventListener

    \Description
        Adds a registration for basic push events

    \Input pRef             - module state
    \Input eventType        - event type from sony ie "np:service:presence2:onlineStatus"
    \Input pCallback        - function to call when the event triggers
    \Input pUserData        - data passed to the callback when it triggers

     \Output
        int32_t             - positive for success returns the ds request id; negative for error

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiAddPushEventListener(DirtyWebApiRefT *pRef, const char * eventType, DirtyWebApiPushEventCallbackT *pCallback, void *pUserData)
{
    return(DirtyWebApiAddPushEventListenerEx(pRef, eventType, NULL, SCE_NP_DEFAULT_SERVICE_LABEL, pCallback, pUserData));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiAddPushEventListenerEx

    \Description
        Adds a registration for push events, gives access to the "service" apis

    \Input pRef             - module state
    \Input eventType        - event type from sony ie "np:service:invitation"
    \Input pNpServiceName   - NP web service generating the event ie "sessionInvitation"
    \Input npServiceLabel   - more detail on the web service, usually SCE_NP_DEFAULT_SERVICE_LABEL
    \Input pCallback        - function to call when the event triggers
    \Input pUserData        - data passed to the callback when it triggers

    \Output
        int32_t             - positive for success returns the ds request id; negative for error

    \Version 07/20/2013 (cvienneau)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiAddPushEventListenerEx(DirtyWebApiRefT *pRef, const char * eventType, const char * pNpServiceName, SceNpServiceLabel npServiceLabel, DirtyWebApiPushEventCallbackT *pCallback, void *pUserData)
{
    DirtyWebApi2EventCallbackT Callback;
    Callback.eEventType = DIRTYWEBAPI2_PUSH_EVENT;
    Callback.pPushEventCallback = pCallback;

    return(_DirtyWebApi2AddPushEventAsync(pRef, eventType, pNpServiceName, npServiceLabel, &Callback, pUserData));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiAddPushEventContextListener

    \Description
        Adds a registration for push event context

    \Input pRef             - module state
    \Input eventType        - event type from sony ie "np:service:invitation"
    \Input callback         - function to call when the event triggers
    \Input pUserData        - data passed to the callback when it triggers

    \Output
        int32_t             - positive for success returns the ds request id; negative for error

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiAddPushEventContextListener(DirtyWebApiRefT *pRef, const char * eventType, DirtyWebApiPushEventConextCallbackT *callback, void *pUserData)
{
    return(DirtyWebApiAddPushEventContextListenerEx(pRef, eventType, NULL, SCE_NP_DEFAULT_SERVICE_LABEL, callback, pUserData));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiAddPushEventContextListenerEx

    \Description
        Adds a registration for push event context

    \Input pRef             - module state
    \Input eventType        - event type from sony ie "np:service:invitation"
    \Input pNpServiceName   - NP web service generating the event ie "sessionInvitation"
    \Input npServiceLabel   - more detail on the web service, usually SCE_NP_DEFAULT_SERVICE_LABEL
    \Input pCallback        - function to call when the event triggers
    \Input pUserData        - data passed to the callback when it triggers

    \Output
        int32_t             - positive for success returns the ds request id; negative for error

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiAddPushEventContextListenerEx(DirtyWebApiRefT *pRef, const char * eventType, const char * pNpServiceName, SceNpServiceLabel npServiceLabel, DirtyWebApiPushEventConextCallbackT *pCallback, void *pUserData)
{
    DirtyWebApi2EventCallbackT Callback;
    Callback.eEventType = DIRTYWEBAPI2_PUSH_EVENT_CONTEXT;
    Callback.pPushEventContextCallback = pCallback;

    return(_DirtyWebApi2AddPushEventAsync(pRef, eventType, pNpServiceName, npServiceLabel, &Callback, pUserData));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiRemovePushEventListener

    \Description
        Removes a registration for basic push events

    \Input *pRef            - module state
    \Input iRequestId       - id returend from DirtyWebApiAddPushEventListener*
    \Input *pCallback       - function to remove

    \Output
        int32_t             - 0 for success; negative for error

    \Version 09/04/2013 (amakoukji)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiRemovePushEventListener(DirtyWebApiRefT *pRef, int32_t iRequestId, DirtyWebApiPushEventCallbackT *pCallback)
{
    DirtyWebApi2EventCallbackT Callback;
    Callback.pPushEventCallback = pCallback;
    Callback.eEventType = DIRTYWEBAPI2_PUSH_EVENT;
    return(_DirtyWebApiRemovePushEventListnenerCommon(pRef, iRequestId, &Callback));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiRemovePushEventContextListener

    \Description
        Removes a registration for push event push context

    \Input *pRef            - module state
    \Input iRequestId       - id returend from DirtyWebApiAddPushEventListener*
    \Input *pCallback       - function to remove

    \Output
        int32_t             - 0 for success; negative for error

    \Version 11/04/2019 (tcho)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiRemovePushEventContextListener(DirtyWebApiRefT *pRef, int32_t iRequestId, DirtyWebApiPushEventConextCallbackT *pCallback)
{
    DirtyWebApi2EventCallbackT Callback;
    Callback.pPushEventContextCallback = pCallback;
    Callback.eEventType = DIRTYWEBAPI2_PUSH_EVENT_CONTEXT;
    return(_DirtyWebApiRemovePushEventListnenerCommon(pRef, iRequestId, &Callback));
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiCreatePushContext

    \Description
        Creates and starts a push context

    \Input *pRef                - module state
    \Input  iUserIndex          - user index
    \Input  pPushContextId      - buffer to hold the created push context id

    \Output
        int32_t             - 0 for success; negative for error

    \Version 12/04/2019 (tcho)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiCreatePushContext(DirtyWebApiRefT *pRef, int32_t iUserIndex, SceNpWebApi2PushEventPushContextId *pPushContextId)
{
    int32_t iResult;

    // check for buffer size
    if (pPushContextId == NULL)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiCreatePushContext() invalid argument\n", pRef));
        return(-1);
    }

    // check for user context
    if ((iResult = _DirtyWebApi2SetupWebUserContext(pRef, iUserIndex)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiCreatePushContext() No valid user web context for user: %d\n", pRef, iUserIndex));
        return(-3);
    }

    // create a push context
    if ((iResult = sceNpWebApi2PushEventCreatePushContext(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pPushContextId)) != SCE_OK)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiCreatePushContext() sceNpWebApi2PushEventCreatePushContext failed, (err=%s)\n", pRef, DirtyErrGetName(iResult)));
        return(iResult);
    }

    // start the push context
    if ((iResult = sceNpWebApi2PushEventStartPushContextCallback(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pPushContextId)) != SCE_OK)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiCreatePushContext() sceNpWebApi2PushEventStartPushContextCallback failed, push context id: %s (err=%s)\n", pRef, pPushContextId->uuid, DirtyErrGetName(iResult)));
        return(iResult);
    }

    return(0);
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiDeletePushContext

    \Description
        Deletes a push context

    \Input *pRef                - module state
    \Input  iUserIndex          - user index
    \Input  pPushContextId      - push context id to be deleted

    \Output
        int32_t             - 0 for success; negative for error

    \Version 12/04/2019 (tcho)
*/
/*************************************************************************************F*/
int32_t DirtyWebApiDeletePushContext(DirtyWebApiRefT *pRef, int32_t iUserIndex, SceNpWebApi2PushEventPushContextId *pPushContextId)
{
    int32_t iResult;

    // check for user context
    if ((iResult = _DirtyWebApi2SetupWebUserContext(pRef, iUserIndex)) < 0)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiDeletePushContext() No valid user web context for user: %d\n", pRef, iUserIndex));
        return(-1);
    }

    if ((iResult = sceNpWebApi2PushEventDeletePushContext(pRef->webApi2Users[iUserIndex].iWebapi2UserCtxId, pPushContextId)) != SCE_OK)
    {
        NetPrintf(("dirtywebapi2ps5: [%p] DirtyWebApiDeletePushContext() sceNpWebApi2PushEventDeletePushContext failed push context id: %s (err=%s)\n", pRef, pPushContextId->uuid, DirtyErrGetName(iResult)));
        return(iResult);
    }

    return(0);
}

/*F*************************************************************************************/
/*!
    \Function    DirtyWebApiControl

    \Description
        Destroy the module and release its state

    \Input *pRef    - reference pointer
    \Input iControl - control selector
    \Input iValue   - control value
    \Input iValue2  - control value
    \Input *pValue  - [in/out] control value

    \Output
        int32_t    - negative=error, else success

        \verbatim
            auto: set auto-update enable/disable - iValue=TRUE or FALSE (default TRUE)
            qcal: TRUE to enable callback queuing else FALSE. All non push event callback if queue will be executed by the NetConnIdle thread
            rbuf: set the read buffer size.
        \endverbatim

    \Version 05/22/2013 (amakoukji)
*/
/****************************************************************************************F*/
int32_t DirtyWebApiControl(DirtyWebApiRefT *pRef, int32_t iControl, int32_t iValue, int32_t iValue2, void *pValue)
{
    if (pRef == NULL)
    {
        return(-1);
    }

    // enable/disable auto-update feature
    if (iControl == 'auto')
    {
        pRef->bAutoUpdate = iValue;
        return(0);
    }

    // enable or disble queuing of callbacks to be call later by _DirtyWebApi2Update()
    if (iControl == 'qcal')
    {
        NetPrintf(("dirtywebapi2ps5: %s the queuing of dirtywebapi request callback.\n", iValue ? "Enable" : "Disable"));
        pRef->bQueueCallback = iValue;
        return(0);
    }

    // set the read buffer size
    if (iControl == 'rbuf')
    {
        if (iValue < 0)
        {
            NetPrintf(("dirtywebapi2ps5: Invalid read buffer size %d\n", iValue));
            return(-1);
        }
        else if ((uint32_t)iValue > pRef->uReadBufferSize)
        {
            NetCritEnter(&pRef->requestCrit);
            char *pTmp = (char*)DirtyMemAlloc(iValue, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            if (pTmp == NULL)
            {
                NetPrintf(("dirtywebapi2ps5: Unable to grow read buffer [%p] to size %d\n", pRef, iValue));
                return(-1);
            }
            DirtyMemFree(pRef->aReadBuffer, DIRTYWEBAPI_MEMID, pRef->iMemGroup, pRef->pMemGroupUserData);
            pRef->aReadBuffer = pTmp;
            pRef->uReadBufferSize = (uint32_t)iValue;
            NetCritLeave(&pRef->requestCrit);
        }

        return(iValue);
    }

    return(-1);
}

/*F*************************************************************************************************/
/*!
    \Function    DirtyWebApiStatus

    \Description
        Different status selectors do different functions

    \Input *pRef    - reference pointer
    \Input iStatus - status selector
    \Input iValue   - status value
    \Input *pBuf    - buffer to pass outputs
    \Input iBufSize - [in/out] buffer size value

    \Output
        int32_t    - negative=error, else success

        \verbatim
            qcal: return true if queuing is enabled
        \endverbatim

    \Version 07/21/2015 (tcho)
*/
/*************************************************************************************************F*/
int32_t DirtyWebApiStatus(DirtyWebApiRefT *pRef, int32_t iStatus, int32_t iValue, void* pBuf, int32_t iBufSize)
{
    // return true if queuing is enabled
    if (iStatus == 'qcal')
    {
        return (pRef->bQueueCallback);
    }

    return (-1);
}
